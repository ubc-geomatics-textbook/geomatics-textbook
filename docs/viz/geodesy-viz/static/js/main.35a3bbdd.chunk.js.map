{"version":3,"sources":["Components/CoordinateLine.js","Components/SpherePoint.js","Components/Intersections.js","Components/Loading.js","Components/Geoid.js","Components/Spheroids.js","Components/OverlayText.js","Components/GeoidHeightDisplay.js","Components/Visualization.js","Components/ControlsAndLight.js","App.js","index.js"],"names":["CoordinateLine","latitude","longitude","edgeColor","theta","convertLongitudeToSpherical","phi","convertLatitudeToSpherical","spherical","THREE","MODEL_RADIUS","endpoint","setFromSpherical","MovingLine","start","end","props","bufferGeometryRef","useRef","useLayoutEffect","vertices","current","setFromPoints","attach","ref","color","latitudeDeg","MathUtils","degToRad","longitudeDeg","NORMAL_COLOR","SpherePoint","position","materialRef","useState","hover","setHover","useFrame","set","onPointerOver","onPointerOut","args","SphereIntersection","intersection","lat","lon","setFromSphericalCoords","getSphereIntersection","EllipsoidIntersection","flattening","latRad","lonRad","z","Math","cos","x","sin","y","R","sqrt","multiplyScalar","getEllipsoidIntersection","RaycastIntersection","modelName","scene","useThree","raycaster","useMemo","r","layers","MODEL_LAYER","makeSafe","rayStart","clone","negate","normalize","modelIntersection","intersectObjects","children","find","object","name","console","log","point","LoadingScreen","Html","transform","fullscreen","className","GEOID_MODEL_PATH","Geoid","isVisible","fallback","GeoidModel","useGLTF","nodes","materials","dispose","rotation","PI","geometry","Sphere","material","GeoidFlatMaterial","scale","visible","preload","ScaledSphere","Ellipsoid","semimajorAxis","sphereGeometry","SphereBufferGeometry","radius","widthSegments","opacity","transparent","depthWrite","OverlayText","text","style","top","left","calculatePosition","geoidHeightCanvasId","GeoidHeightCanvas","canvasRef","useEffect","image","Image","src","onload","getContext","drawImage","hidden","id","width","height","GeoidHeightDisplay","geoidHeight","context","getImgXYFromCoordinates","imgX","imgY","pixelValue","minHeight","round","pixelToGeoidHeight","getImageData","data","lookupGeoidHeight","document","getElementById","GRATICULE_COLOR","WGSFlattening","Visualization","useControls","showGeoidHeight","value","render","buttonGroup","geoid","sphere","get","hint","min","max","ellipsoid","onChange","onEllipsoidChange","transient","step","Models","geoidVisibility","sphereOpacity","ellipsoidOpacity","sphereIntersection","ellipsoidIntersection","SetCameraLayers","camera","enable","FreeControls","gl","controls","autoRotate","button","reset","update","OrbitControls","minDistance","maxDistance","autoRotateSpeed","CameraAlignedLight","light","matrixAutoUpdate","intensity","followCamera","offset","collapsed","matrix","copy","cameraMatrix","offsetDegrees","frameMatrix","setPosition","frameMatrixInv","invert","rotationMatrix","makeRotationY","multiply","calculateLightMatrix","matrixWorld","App","Stats","ReactDOM"],"mappings":"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","file":"static/js/main.35a3bbdd.chunk.js","sourcesContent":["import * as THREE from \"three\";\r\nimport { MathUtils } from \"three\";\r\nimport React, { useLayoutEffect, useRef } from \"react\";\r\nimport { MODEL_RADIUS } from \"./Visualization\";\r\n\r\n/**\r\n * Draws a line emanating from (0, 0, 0) whose angle corresponds to the latitude and longitude.\r\n */\r\nexport function CoordinateLine({ latitude, longitude, edgeColor }) {\r\n    const theta = convertLongitudeToSpherical(longitude);\r\n    const phi = convertLatitudeToSpherical(latitude);\r\n\r\n    const spherical = new THREE.Spherical(MODEL_RADIUS * 2, phi, theta);\r\n    const endpoint = new THREE.Vector3().setFromSpherical(spherical);\r\n\r\n    return (\r\n        <MovingLine\r\n            start={new THREE.Vector3(0, 0, 0)}\r\n            end={endpoint}\r\n            edgeColor={edgeColor}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * A line segment with dynamic endpoints.\r\n */\r\nfunction MovingLine(props) {\r\n    const bufferGeometryRef = useRef();\r\n\r\n    useLayoutEffect(() => {\r\n            const vertices = [\r\n                props.start,\r\n                props.end\r\n            ];\r\n            bufferGeometryRef.current.setFromPoints(vertices);\r\n        },\r\n        [props.start, props.end]\r\n    );\r\n\r\n    return (\r\n        <line>\r\n            <bufferGeometry\r\n                attach=\"geometry\"\r\n                ref={bufferGeometryRef}\r\n            />\r\n            <lineBasicMaterial\r\n                attach=\"material\"\r\n                color={props.edgeColor}\r\n            />\r\n        </line>\r\n    );\r\n}\r\n\r\n/**\r\n * Converts a latitude angle between -90 and 90 degrees to polar angle in radians.\r\n * @param latitudeDeg Latitude, in degrees. Must be an integer value in [-90, 90].\r\n * @returns {*} Polar angle (spherical coordinates) in radians.\r\n */\r\nexport function convertLatitudeToSpherical(latitudeDeg) {\r\n    return MathUtils.degToRad(90 - latitudeDeg);\r\n}\r\n\r\n/**\r\n * Converts a longitude angle between -180 and 180 degrees to azimuthal angle in radians.\r\n * @param longitudeDeg Longitude, in degrees. Must be an integer value in [-180, 180].\r\n * @returns {*} Azimuthal angle (spherical coordinates) in radians.\r\n */\r\nexport function convertLongitudeToSpherical(longitudeDeg) {\r\n    return MathUtils.degToRad(longitudeDeg);\r\n}","import React, { useRef, useState } from \"react\";\r\nimport { useFrame } from \"@react-three/fiber\";\r\nimport { MODEL_RADIUS } from \"./Visualization\";\r\n\r\n/**\r\n * The color of a {@link SpherePoint} when not hovered over.\r\n * @type {string}\r\n */\r\nconst NORMAL_COLOR = \"#00ffbb\";\r\n\r\n/**\r\n * The color of a {@link SpherePoint} when hovered over.\r\n * @type {string}\r\n */\r\nconst HOVER_COLOR = \"#ff0090\";\r\n\r\n/**\r\n * A small spherical point that can be placed at a given world position in the scene.\r\n * Changes color when hovered over.\r\n */\r\nexport function SpherePoint({ position }) {\r\n    const materialRef = useRef();\r\n    const [hover, setHover] = useState(false);\r\n\r\n    useFrame(() => {\r\n        materialRef.current.color.set(hover ? HOVER_COLOR : NORMAL_COLOR);\r\n    });\r\n\r\n    return (\r\n        <mesh\r\n            position={position}\r\n\r\n            onPointerOver={() => setHover(true)}\r\n            onPointerOut={() => setHover(false)}\r\n        >\r\n            <sphereBufferGeometry\r\n                attach=\"geometry\"\r\n                args={[MODEL_RADIUS / 80, 10, 5]}\r\n            />\r\n            <meshStandardMaterial\r\n                attach=\"material\"\r\n                ref={materialRef}\r\n                color={NORMAL_COLOR}\r\n            />\r\n        </mesh>\r\n    );\r\n}","import React, { useMemo } from \"react\";\r\nimport * as THREE from \"three\";\r\nimport { MathUtils } from \"three\";\r\nimport { useThree } from \"@react-three/fiber\";\r\nimport { MODEL_LAYER, MODEL_RADIUS } from \"./Visualization\";\r\nimport { convertLatitudeToSpherical, convertLongitudeToSpherical } from \"./CoordinateLine\";\r\nimport { SpherePoint } from \"./SpherePoint\";\r\n\r\n/**\r\n * Draws a point at the intersection of the coordinate line and the sphere.\r\n */\r\nexport function SphereIntersection( {latitude, longitude} ) {\r\n    const intersection = getSphereIntersection(latitude, longitude);\r\n\r\n    return (\r\n        <SpherePoint\r\n            position={intersection}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Draws a point at the intersection of the coordinate line and the ellipsoid.\r\n */\r\nexport function EllipsoidIntersection( {latitude, longitude, flattening} ) {\r\n    const intersection = getEllipsoidIntersection(latitude, longitude, flattening);\r\n\r\n    return (\r\n        <SpherePoint\r\n            position={intersection}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Computes the position of the sphere intersection.\r\n * @param lat Latitude, in degrees.\r\n * @param lon Longitude, in degrees.\r\n * @returns {Vector3} The world position of the intersection of the sphere and the coordinate line.\r\n */\r\nfunction getSphereIntersection(lat, lon) {\r\n    const theta = convertLongitudeToSpherical(lon);\r\n    const phi = convertLatitudeToSpherical(lat);\r\n\r\n    return new THREE.Vector3().setFromSphericalCoords(MODEL_RADIUS, phi, theta);\r\n}\r\n\r\n/**\r\n * Computes the position of the ellipsoid intersection.\r\n * @param lat Latitude, in degrees.\r\n * @param lon Longitude, in degrees.\r\n * @param flattening Flattening factor of the ellipsoid.\r\n * @returns {Vector3} The world position of the intersection of the ellipsoid and the coordinate line.\r\n */\r\nfunction getEllipsoidIntersection(lat, lon, flattening) {\r\n    // World space position on the surface of the ellipsoid, from true spherical coordinates (geocentric latitude â€“ I think)\r\n    // Formula source: https://en.wikipedia.org/wiki/Ellipsoid#Parameterization\r\n\r\n    const latRad = MathUtils.degToRad(lat);\r\n    const lonRad = MathUtils.degToRad(lon);\r\n\r\n    const z = Math.cos(latRad) * Math.cos(lonRad);\r\n    const x = Math.cos(latRad) * Math.sin(lonRad);\r\n    const y = Math.sin(latRad);\r\n\r\n    const R = (1 - flattening) * MODEL_RADIUS /\r\n        Math.sqrt(((1 - flattening) * Math.cos(latRad)) ** 2 + Math.sin(latRad) ** 2);\r\n\r\n    return new THREE.Vector3(x, y, z).multiplyScalar(R);\r\n}\r\n\r\n/**\r\n * Draws a point at the intersection of the coordinate line and the first intersected object in the layer\r\n * {@link MODEL_LAYER} that has the given model name. If no intersection is found, draws nothing.\r\n *\r\n * This is meant to be used to detect the intersection of the coordinate line and the geoid, since the geoid surface\r\n * is irregular.\r\n */\r\nexport function RaycastIntersection({ latitude, longitude, modelName } ) {\r\n    const { scene } = useThree();\r\n\r\n    const raycaster = useMemo(() => {\r\n        const r = new THREE.Raycaster();\r\n        r.layers.set(MODEL_LAYER);\r\n\r\n        return r;\r\n    }, []);\r\n\r\n    const theta = convertLongitudeToSpherical(longitude);\r\n    const phi = convertLatitudeToSpherical(latitude);\r\n    const spherical = new THREE.Spherical(MODEL_RADIUS * 2, phi, theta).makeSafe();\r\n    const rayStart = new THREE.Vector3().setFromSpherical(spherical);\r\n\r\n    raycaster.set(rayStart, rayStart.clone().negate().normalize());\r\n\r\n    const intersections = raycaster.intersectObjects(scene.children, true);\r\n\r\n    const modelIntersection = intersections.find((intersection) => intersection.object.name === modelName);\r\n\r\n    console.log(\"Performed a raycast: \" + modelIntersection);\r\n\r\n    if (modelIntersection) {\r\n        return (\r\n            <SpherePoint\r\n                position={modelIntersection.point}\r\n            />\r\n        );\r\n    } else {\r\n        return null;\r\n    }\r\n}","import { Html } from \"@react-three/drei\";\r\nimport \"./styles/loading_screen.css\";\r\n\r\nexport function LoadingScreen() {\r\n    return (\r\n        <Html\r\n            transform={false}\r\n            fullscreen\r\n            className=\"loading-screen\"\r\n        >\r\n            <p className=\"loading-screen-text\">\r\n                Loading . . .\r\n            </p>\r\n        </Html>\r\n    );\r\n}","import React, { Suspense } from \"react\";\r\nimport { useGLTF } from \"@react-three/drei\";\r\nimport { MODEL_LAYER, MODEL_RADIUS } from \"./Visualization\";\r\nimport { RaycastIntersection } from \"./Intersections\";\r\nimport { LoadingScreen } from \"./Loading\";\r\n\r\nconst GEOID_MODEL_PATH = \"./models/Geoid.glb\";\r\n\r\n/**\r\n * Imports the 3D model of the EGM2008 geoid (asset created specifically for this project).\r\n *\r\n * Auto-generated by: https://github.com/pmndrs/gltfjsx\r\n*/\r\nexport function Geoid({ isVisible, latitude, longitude }) {\r\n    const modelName = \"geoid\";\r\n\r\n    return (\r\n        <Suspense fallback={<LoadingScreen />}>\r\n            <GeoidModel name={modelName} isVisible={isVisible}/>\r\n            {\r\n                isVisible ?\r\n                    <RaycastIntersection\r\n                        latitude={latitude}\r\n                        longitude={longitude}\r\n                        modelName={modelName}\r\n                    /> : null\r\n            }\r\n        </Suspense>\r\n    );\r\n}\r\n\r\nfunction GeoidModel({name, isVisible}) {\r\n    const { nodes, materials } = useGLTF(GEOID_MODEL_PATH);\r\n\r\n    // Rotate the model so that longitude = 0 corresponds to the positive z-axis\r\n    //                          longitude > 0 corresponds to positive angle around y-axis\r\n    //                          longitude < 0 corresponds to negative angle around y-axis\r\n    return (\r\n        <group dispose={null} rotation={[0, Math.PI / 2, 0]}>\r\n            <mesh\r\n                geometry={nodes.Sphere.geometry}\r\n                material={materials.GeoidFlatMaterial}\r\n\r\n                name={name}\r\n                layers={MODEL_LAYER}\r\n                scale={MODEL_RADIUS}\r\n                visible={isVisible}\r\n            />\r\n        </group>\r\n    );\r\n}\r\n\r\nuseGLTF.preload(GEOID_MODEL_PATH)\r\n","import {SphereBufferGeometry} from \"three\";\r\nimport React, {useMemo} from \"react\";\r\nimport {MODEL_LAYER} from \"./Visualization\";\r\n\r\n/**\r\n * Number of width segments of the sphere and ellipsoid.\r\n * @type {number}\r\n */\r\nconst widthSegments = 48;\r\n\r\n/**\r\n * Number of height segments of the sphere and ellipsoid.\r\n * @type {number}\r\n */\r\nconst heightSegments = widthSegments / 2;\r\n\r\n/**\r\n * Displays a sphere, one of the 3 primary models in the visualization.\r\n */\r\nexport function Sphere(props) {\r\n    return (\r\n        <ScaledSphere\r\n            scale={1}\r\n            {...props}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Displays an ellipsoid, one of the 3 primary models in the visualization.\r\n */\r\nexport function Ellipsoid(props) {\r\n    return (\r\n        <ScaledSphere\r\n            scale={[1, findSemiminorAxis(props.flattening, 1), 1]}\r\n            {...props}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Computes the y-scale of the ellipsoid from the flattening factor.\r\n * @param flattening Flattening factor.\r\n * @param semimajorAxis The ellipsoid's x/z scales, assumed to be equal (semimajor axis).\r\n * @returns {number} The y-scale (semiminor axis).\r\n */\r\nfunction findSemiminorAxis(flattening, semimajorAxis) {\r\n    return (1 - flattening) * semimajorAxis;\r\n}\r\n\r\n/**\r\n * Draws a transparent sphere-like object with arbitrary x, y, and z scales.\r\n * This component is the basis for the sphere and ellipsoid models.\r\n */\r\nfunction ScaledSphere(props) {\r\n    const sphereGeometry = useMemo(() => {\r\n        return new SphereBufferGeometry(props.radius, widthSegments, heightSegments);\r\n    }, [props.radius]);\r\n\r\n    return (\r\n        <group\r\n            scale={props.scale}\r\n        >\r\n            <mesh\r\n                geometry={sphereGeometry}\r\n                layers={MODEL_LAYER}\r\n                visible={props.opacity > 0}\r\n            >\r\n                <meshStandardMaterial\r\n                    attach=\"material\"\r\n                    color={props.color}\r\n                    transparent={true}\r\n                    opacity={props.opacity}\r\n                />\r\n            </mesh>\r\n            <lineSegments>\r\n                <edgesGeometry\r\n                    attach=\"geometry\"\r\n                    args={[sphereGeometry]}\r\n                />\r\n                <lineBasicMaterial\r\n                    attach=\"material\"\r\n                    color={props.edgeColor}\r\n                    transparent={true}\r\n                    opacity={props.opacity}\r\n                    depthWrite={false}\r\n                />\r\n            </lineSegments>\r\n        </group>\r\n    );\r\n}","import { Html } from \"@react-three/drei\";\r\nimport React from \"react\";\r\n\r\n/**\r\n * Text overlaid on top of the viewport in the upper left corner.\r\n */\r\nexport function OverlayText({ text }) {\r\n    return (\r\n        <Html\r\n            transform={false}\r\n            style={{\r\n                position: \"relative\",\r\n                top: 70,\r\n                left: 20,\r\n                \"fontFamily\": \"courier\",\r\n                \"color\": \"white\"\r\n            }}\r\n            calculatePosition={() => [0, 0]}\r\n        >\r\n            {text}\r\n        </Html>\r\n    )\r\n}","import { Html } from \"@react-three/drei\";\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport { OverlayText } from \"./OverlayText\";\r\n\r\nconst geoidHeightImageSrc = \"./geoid-height-grid.png\";\r\nconst geoidHeightCanvasId = \"geoid-height-grid\";\r\n\r\n/**\r\n * A hidden canvas containing a grid of geoid heights.\r\n * This canvas is used as a lookup table for the geoid height, so it must be included in the scene.\r\n */\r\nexport function GeoidHeightCanvas() {\r\n    const canvasRef = useRef();\r\n\r\n    useEffect(() => {\r\n        const image = new Image(361, 181);\r\n        image.src = geoidHeightImageSrc;\r\n\r\n        image.onload = () => {\r\n            console.log(\"Finished loading geoid height image.\");\r\n\r\n            const context = canvasRef.current.getContext(\"2d\");\r\n            context.drawImage( image, 0, 0 );\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <Html>\r\n            <canvas\r\n                ref={canvasRef}\r\n                hidden\r\n                id={geoidHeightCanvasId}\r\n                width={361}\r\n                height={181}\r\n            />\r\n        </Html>\r\n    );\r\n}\r\n\r\n/**\r\n * Displays the geoid height at the given latitude and longitude in the upper left corner.\r\n */\r\nexport function GeoidHeightDisplay({ latitude, longitude }) {\r\n    const canvas = document.getElementById(geoidHeightCanvasId);\r\n\r\n    const context = canvas.getContext(\"2d\");\r\n    const geoidHeight = lookupGeoidHeight(context, latitude, longitude);\r\n\r\n    return (\r\n        <OverlayText\r\n            text = {\"Geoid height: \" + geoidHeight + \" m\"}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Finds the geoid height at the given coordinates.\r\n * @param context The 2d context of the canvas where the lookup image is stored.\r\n * @param lat Latitude, in degrees.\r\n * @param lon Longitude, in degrees.\r\n * @returns {number} The geoid height, in meters, rounded to the nearest integer.\r\n */\r\nfunction lookupGeoidHeight( context, lat, lon ) {\r\n    const [ imgX, imgY ] = getImgXYFromCoordinates(lon, lat);\r\n\r\n    const data = context.getImageData(imgX, imgY, 1, 1).data;\r\n\r\n    return pixelToGeoidHeight(data[0]);\r\n}\r\n\r\nfunction getImgXYFromCoordinates(lon, lat) {\r\n    return [lon + 180 , 90 - lat]\r\n}\r\n\r\n/**\r\n * Decodes the rounded geoid height from the stored pixel value.\r\n *\r\n * The geoid heights were stored according to a linear scale, where pixel=0 corresponds to the minimum geoid height\r\n * in the dataset, and pixel=255 corresponds to the maximum.\r\n * @param pixelValue The value of the pixel in the lookup image. Should be an integer in [0, 255].\r\n * @returns {number} The geoid height, in meters, rounded to the nearest integer.\r\n */\r\nfunction pixelToGeoidHeight(pixelValue) {\r\n    const maxHeight = 78.21;\r\n    const minHeight = -106.57;\r\n\r\n    const height = minHeight + pixelValue / 255 * (maxHeight - minHeight);\r\n\r\n    return Math.round(height);\r\n}","import { buttonGroup, useControls } from \"leva\";\r\nimport React from \"react\";\r\nimport { Geoid } from \"./Geoid\";\r\nimport { Ellipsoid, Sphere } from \"./Spheroids\";\r\nimport { CoordinateLine } from \"./CoordinateLine\";\r\nimport { GeoidHeightCanvas, GeoidHeightDisplay } from \"./GeoidHeightDisplay\";\r\nimport { EllipsoidIntersection, SphereIntersection } from \"./Intersections\";\r\n\r\n/**\r\n * Edge color of the graticules on the sphere/ellipsoid.\r\n * @type {string}\r\n */\r\nconst GRATICULE_COLOR = \"#ffffff\";\r\n\r\n/**\r\n * Color of the body of the ellipsoid.\r\n * @type {string}\r\n */\r\nconst ELLIPSOID_COLOR = \"#5e78ce\";\r\n\r\n/**\r\n * Color of the body of the sphere.\r\n * @type {string}\r\n */\r\nconst SPHERE_COLOR = \"#d0749c\";\r\n\r\n/**\r\n * Color of the coordinate line.\r\n * @type {string}\r\n */\r\nconst LINE_COLOR = \"#0022ff\";\r\n\r\n/**\r\n * This value determines the size of the three models. In the sphere/ellipsoid case, it is used to specify the radius of\r\n * the geometry (before scaling).\r\n * @type {number}\r\n */\r\nexport const MODEL_RADIUS = 1;\r\n\r\n/**\r\n * The special layer that the 3 main models are placed into, for more efficient raycasting.\r\n * @type {number}\r\n */\r\nexport const MODEL_LAYER = 5;\r\n\r\n/**\r\n * Constant flattening factor of the WGS84 ellipsoid.\r\n * @type {number}\r\n */\r\nconst WGSFlattening = 1 / 298.257223560;\r\n\r\n/**\r\n * Hint for the Leva control that toggles the geoid visibility.\r\n * @type {string}\r\n */\r\nconst GEOID_CONTROL_HINT = \"Show/hide the geoid\";\r\n\r\n/**\r\n * Hint for the Leva slider that controls the sphere opacity.\r\n * @type {string}\r\n */\r\nconst SPHERE_CONTROL_HINT = \"Change the visibility of the sphere\";\r\n\r\n/**\r\n * Hint for the Leva slider that controls the ellipsoid opacity.\r\n * @type {string}\r\n */\r\nconst ELLIPSOID_CONTROL_HINT = \"Change the visibility of the ellipsoid\";\r\n\r\n/**\r\n * Hint for the Leva slider that controls the ellipsoid flattening.\r\n * @type {string}\r\n */\r\nconst FLATTENING_CONTROL_HINT = \"Change the flattening factor of the ellipsoid\";\r\n\r\n/**\r\n * Hint for the Leva slider that controls the latitude.\r\n * @type {string}\r\n */\r\nconst LATITUDE_CONTROL_HINT = \"Change the latitude (degrees)\";\r\n\r\n/**\r\n * Hint for the Leva slider that controls the longitude.\r\n * @type {string}\r\n */\r\nconst LONGITUDE_CONTROL_HINT = \"Change the longitude (degrees)\";\r\n\r\n/**\r\n * Renders the main content of the visualization, including the coordinate line, models, etc.\r\n * Adds the \"Models\" and \"Coordinates\" folders to the Leva controls.\r\n */\r\nexport function Visualization() {\r\n    const [{ geoid, sphere, ellipsoid, flattening, showGeoidHeight }, set] = useControls(\"Models\", () => ({\r\n        showGeoidHeight: {\r\n            value: false,\r\n            render: () => false\r\n        },\r\n        \"geoid height\": buttonGroup({\r\n            \"on\": () => {\r\n                set({\r\n                    showGeoidHeight: true,\r\n                    geoid: true,\r\n                    sphere: 0,\r\n                    flattening: WGSFlattening,\r\n                });\r\n            },\r\n            \"off\": () => set({ showGeoidHeight: false }),\r\n        }),\r\n        geoid: {\r\n            value: true,\r\n            render: (get) => !get(\"Models.showGeoidHeight\"),\r\n            hint: GEOID_CONTROL_HINT,\r\n        },\r\n        sphere: {\r\n            value: 0,\r\n            min: 0,\r\n            max: 1,\r\n            render: (get) => !get(\"Models.showGeoidHeight\"),\r\n            hint: SPHERE_CONTROL_HINT,\r\n        },\r\n        ellipsoid: {\r\n            value: 0,\r\n            min: 0,\r\n            max: 1,\r\n            hint: ELLIPSOID_CONTROL_HINT,\r\n            onChange: onEllipsoidChange,\r\n            transient: false,\r\n        },\r\n        flattening: {\r\n            value: WGSFlattening,\r\n            min: 0,\r\n            max: 1,\r\n            render: (get) => !get('Models.showGeoidHeight'),\r\n            hint: FLATTENING_CONTROL_HINT,\r\n        },\r\n    }));\r\n\r\n    function onEllipsoidChange () {\r\n        console.log(sphere);                  // this always prints 0\r\n        set({ sphere: 0 });             // this DOES set the sphere, but we can't read the value of the sphere\r\n    }\r\n\r\n    const {latitude, longitude} = useControls(\"Coordinates\", {\r\n        latitude: {\r\n            value: 0,\r\n            min: -90,\r\n            max: 90,\r\n            step: 1,\r\n            hint: LATITUDE_CONTROL_HINT,\r\n        },\r\n        longitude: {\r\n            value: 0,\r\n            min: -180,\r\n            max: 180,\r\n            step: 1,\r\n            hint: LONGITUDE_CONTROL_HINT,\r\n        }\r\n    });\r\n\r\n    return (\r\n        <>\r\n            <GeoidHeightCanvas/>\r\n            <Models\r\n                latitude={latitude}\r\n                longitude={longitude}\r\n\r\n                geoidVisibility={geoid}\r\n                sphereOpacity={sphere}\r\n                ellipsoidOpacity={ellipsoid}\r\n                flattening={flattening}\r\n            />\r\n            <CoordinateLine\r\n                latitude={latitude}\r\n                longitude={longitude}\r\n                flattening={flattening}\r\n\r\n                edgeColor={LINE_COLOR}\r\n            />\r\n            {\r\n                showGeoidHeight ?\r\n                <GeoidHeightDisplay\r\n                    latitude={latitude}\r\n                    longitude={longitude}\r\n                /> : null\r\n            }\r\n        </>\r\n    );\r\n}\r\n\r\n/**\r\n * Renders the 3 primary models and their respective intersections with the coordinate line.\r\n */\r\nfunction Models({latitude, longitude, geoidVisibility, sphereOpacity, ellipsoidOpacity, flattening}) {\r\n    const sphereIntersection = sphereOpacity > 0 ? (\r\n        <SphereIntersection\r\n            latitude={latitude}\r\n            longitude={longitude}\r\n        />\r\n    ) : null;\r\n\r\n    const ellipsoidIntersection = ellipsoidOpacity > 0 ? (\r\n        <EllipsoidIntersection\r\n            latitude={latitude}\r\n            longitude={longitude}\r\n            flattening={flattening}\r\n        />\r\n    ) : null;\r\n\r\n    return (\r\n        <>\r\n            <Geoid\r\n                latitude={latitude}\r\n                longitude={longitude}\r\n                isVisible={geoidVisibility}\r\n            />\r\n            <Ellipsoid\r\n                opacity={ellipsoidOpacity}\r\n\r\n                color={ELLIPSOID_COLOR}\r\n                edgeColor={GRATICULE_COLOR}\r\n                radius={MODEL_RADIUS}\r\n\r\n                flattening={flattening}\r\n            />\r\n            <Sphere\r\n                opacity={sphereOpacity}\r\n\r\n                color={SPHERE_COLOR}\r\n                edgeColor={GRATICULE_COLOR}\r\n                radius={MODEL_RADIUS}\r\n            />\r\n            {sphereIntersection}\r\n            {ellipsoidIntersection}\r\n        </>\r\n    )\r\n}","import { useFrame, useThree } from \"@react-three/fiber\";\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport { OrbitControls } from \"@react-three/drei\";\r\nimport * as THREE from \"three\";\r\nimport { MathUtils } from \"three\";\r\nimport { button, useControls } from \"leva\";\r\nimport { MODEL_LAYER, MODEL_RADIUS } from \"./Visualization\";\r\n\r\n/**\r\n * Extends the default camera layers to include the layer we moved all models into.\r\n * This is required because we placed the primary models (sphere, ellipsoid, geoid) in a different layer in case we\r\n * have to raycast against them.\r\n */\r\nexport function SetCameraLayers() {\r\n    const { camera } = useThree();\r\n\r\n    useEffect(() => {\r\n        camera.layers.enable(MODEL_LAYER);\r\n    }, [camera.layers]);\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * OrbitControls with some predefined camera settings, including auto-rotation.\r\n *\r\n * Adds the \"Camera\" folder to the Leva controls to toggle the auto-rotation.\r\n */\r\nexport function FreeControls() {\r\n    const { camera, gl } = useThree();\r\n    const controls = useRef();\r\n\r\n    const resetControls = () => {\r\n        controls.current.reset();\r\n    };\r\n\r\n    const { autoRotate } = useControls(\"Camera\", {\r\n        autoRotate: {\r\n            value: false,\r\n            hint: \"Automatically rotate around models\",\r\n        },\r\n        \"Reset view\": button(() => resetControls()),\r\n    });\r\n\r\n    useFrame(() => {\r\n        controls.current.update();\r\n    });\r\n\r\n    return (\r\n        <OrbitControls\r\n            ref={controls}\r\n            args={[camera, gl]}\r\n            minDistance={MODEL_RADIUS + 0.5}\r\n            maxDistance={MODEL_RADIUS * 10}\r\n\r\n            autoRotate={autoRotate}\r\n            autoRotateSpeed={0.5}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * A directional light that shines from a fixed angle relative to the camera.\r\n *\r\n * Adds the \"Lighting\" folder to the Leva controls.\r\n */\r\nexport function CameraAlignedLight() {\r\n\r\n    const light = useRef();\r\n    useEffect(() => {\r\n        light.current.matrixAutoUpdate = false;\r\n    }, []);\r\n    // useHelper(light, THREE.DirectionalLightHelper);\r\n\r\n    const { camera } = useThree();\r\n\r\n    const { intensity, followCamera, offset } = useControls(\"Lighting\", {\r\n        intensity: {\r\n            value: 0.75,\r\n            min: 0,\r\n            max: 2\r\n        },\r\n        followCamera: true,\r\n        offset: {\r\n            value: -65,\r\n            min: -180,\r\n            max: 180,\r\n            step: 1\r\n        }\r\n    }, {\r\n        collapsed: true\r\n    });\r\n\r\n    useFrame(() => {\r\n        if (followCamera) {\r\n            light.current.matrix.copy(calculateLightMatrix(camera.matrixWorld, offset));\r\n        }\r\n    });\r\n\r\n    return (\r\n        <directionalLight\r\n            ref={light}\r\n            intensity={intensity}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Calculates a transformation matrix for the light such that it shines from a fixed offset angle from the camera.\r\n *\r\n * Creates the illusion of rotating the models, when the user is actually rotating the camera.\r\n *\r\n * @param cameraMatrix The camera matrix (matrix that transforms positions in the camera frame to the world frame).\r\n * @param offsetDegrees The angle, in degrees, to offset the light by. A number in [-180, 180].\r\n * @returns {*} The .matrix of the light.\r\n */\r\nfunction calculateLightMatrix(cameraMatrix, offsetDegrees) {\r\n    /*\r\n    Get a frame f that has the same rotation as the camera, but is positioned at the origin of the world.\r\n    The .matrix, F, of frame f is just the camera matrix, except with the position component set to 0.\r\n     */\r\n    const frameMatrix = cameraMatrix.clone().setPosition(0, 0, 0);\r\n    const frameMatrixInv = frameMatrix.clone().invert();\r\n\r\n    /*\r\n    Construct a rotation matrix R that describes a rotation of offsetDegrees degrees about the y axis.\r\n     */\r\n    const rotationMatrix = new THREE.Matrix4().makeRotationY(MathUtils.degToRad(offsetDegrees));\r\n\r\n    /*\r\n    This matrix applies the rotation R with respect to the frame f. Applying it to the camera's local position gives the\r\n    desired world position and rotation of the light.\r\n\r\n    The matrix is calculated as F R F^(-1) C.\r\n     */\r\n    const lightTransformationMatrix = frameMatrix.multiply(rotationMatrix).multiply(frameMatrixInv).multiply(cameraMatrix);\r\n\r\n    return lightTransformationMatrix;\r\n}","import React from 'react'\r\nimport { Canvas } from '@react-three/fiber'\r\nimport './styles.css'\r\nimport { CameraAlignedLight, FreeControls, SetCameraLayers } from \"./Components/ControlsAndLight\";\r\nimport { MODEL_RADIUS, Visualization } from \"./Components/Visualization\";\r\nimport { Stats } from \"@react-three/drei\";\r\n\r\nfunction App() {\r\n    return (\r\n        <Canvas\r\n            camera={{\r\n                position: [MODEL_RADIUS * 2 + 0.5, 0, 0]\r\n            }}\r\n        >\r\n            <SetCameraLayers/>\r\n            <ambientLight intensity={0.15}/>\r\n\r\n            <Visualization/>\r\n\r\n            <CameraAlignedLight/>\r\n            <FreeControls/>\r\n\r\n            <Stats />\r\n        </Canvas>\r\n    );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}